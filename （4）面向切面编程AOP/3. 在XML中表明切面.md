# 在XML中表明切面

为了顺利使用AspectJ，除了Spring框架所需的JAR包，我们还需在开发之前需要导入 aspectj-1.9.1.jar 和 aspectjweaver-1.8.7.jar 这两个额外的JAR包。

Spring在AOP配置命名空间中提供了声明式切面的选择。

| AOP configuration element | Purpose |
|--------|--------|
| &lt;aop:advisor&gt; | 定义一个AOP通知器 |
| &lt;aop:after&gt; | 定义AOP的后置通知，不管被执行的方法是否执行成功，都要通知 |
| &lt;aop:after-return&gt; | 定义一个返回最终的通知 |
| &lt;aop:after-throwing&gt; | 定义一个after-throwing通知，与异常有关|
| &lt;aop:around&gt; | 定义一个环绕通知|
| &lt;aop:aspect&gt; | 定义切面 |
| &lt;aop:aspectj-autoproxy&gt; | 启用使用@AspectJ的AspectJ注解驱动的切面|
| &lt;aop:before&gt; | 定义一个前置通知 |
| &lt;aop:config&gt; | 顶层的AOP配置元素，大多数的&lt;aop:*&gt;元素都必须包含在这里面 |
| &lt;aop:declare-parents&gt; | 为被通知的对象透明的引入额外的接口 |
| &lt;aop:piontcut&gt; | 定义切入点 |

## 示例

中国偶像选秀节目

先定义一个表演接口，里面有表演方法：

```java
package com.li.spring.chineseidol;

public interface Performer {
	void perform() throws PerformanceException;
}

```

接着是一个杂技表演者的类，该类实现了表演接口，并在类中实现了表演方法：

```java
package com.li.spring.chineseidol;

import java.io.File;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Juggler implements Performer {
	private int balls=3;
	
	public int getBalls() {
		return balls;
	}

	public void setBalls(int balls) {
		this.balls = balls;
	}

	@Override
	public void perform() throws PerformanceException {
		System.out.println("JUGGLER "+balls+" BALLS");
	}

	public Juggler() {
		super();
	}
	
	public Juggler(int balls) {
		this.balls=balls;
	}

}

```

假定表演者表演就是我们的业务逻辑，那么我们在这其中穿插一个横切关注点，即为观众的行为，横切面就是观众类。表演过程中，观众有入座、关闭手机、鼓掌、以及吐槽的行为。下面是一个观众类：

```java
package com.li.spring.chineseidol;

import java.io.File;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/*观众类：将观众的一系列行为作为横切关注点*/

@Aspect
public class Audience {

	/*切入点：前置通知*/
	public void takeSeats() {
		System.out.println("观众入座");
	}

	/*前置通知*/
	public void turnOffCellPhone() {
		System.out.println("观众关闭手机");
	}

	/*表演成功的后置通知*/
	public void applaud() {
		System.out.println("鼓掌！");
	}

	/*表演失败的后置通知*/
	public void demandRefund() {
		System.out.println("太糟糕了，我们要求退票！");
	}

}

```

Spring XML 配置文件：chineseidol.xml，位于com.li.spring.chineseidol包下，在配置文件中，先把Juggler类和Audience类注册为Bean。**需要注意的是，要使用aop的命名空间，需要先声明aop的命名空间，并引入aop相关的xsd文件。**

```xml
<?xml version="1.0" encoding="UTF-8"?>

<!-- 引用Spring的多个Schema空间的格式定义文件 -->

<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:p="http://www.springframework.org/schema/p"
	xmlns:aop="http://www.springframework.org/schema/aop"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
	 http://www.springframework.org/schema/beans/spring-beans.xsd
	 http://www.springframework.org/schema/aop
	 http://www.springframework.org/schema/aop/spring-aop.xsd
	 http://www.springframework.org/schema/context
	 http://www.springframework.org/schema/context/spring-context.xsd">

	<bean id="li" class="com.li.spring.chineseidol.Juggler">
		<constructor-arg value="10"></constructor-arg>
	</bean>

	<bean id="audience" class="com.li.spring.chineseidol.Audience"></bean>

	<aop:config>
		<aop:aspect ref="audience">

			<aop:before pointcut="execution(* com.li.spring.chineseidol.Performer.perform(..))" method="takeSeats"/>
			<aop:before pointcut="execution(* com.li.spring.chineseidol.Performer.perform(..))" method="turnOffCellPhone"/>
			<aop:after-returning pointcut="execution(* com.li.spring.chineseidol.Performer.perform(..))" method="applaud"/>
			<aop:after-throwing pointcut="execution(* com.li.spring.chineseidol.Performer.perform(..))" method="demandRefund"/>

		</aop:aspect>
	</aop:config>

</beans>
```

XML配置解释：&lt;aop-config&gt; 是个AOP配置的顶层元素，在这里面定义切面。&lt;aop-aspect&gt; 元素定义了一个切面，其ref属性指明了切面所引用到的Bean。&lt;aop:beforet&gt; 定义的是前置通知，&lt;aop:after-returnt&gt; 定义的是正常返回的后置通知，&lt;aop:after-throwing&gt; 定义的是抛出异常后的后置通知。pointcut属性是一个切入点的定义，其值为AspectJ的切入点定义的表达式（注意表达式中*后面要有空格），表示在什么情况下触发执行后面method属性指明的方法。

这个时候我们给Audience类添加主方法来进行测试：

```java
public static void main(String[] args) {
		ApplicationContext ctx=new ClassPathXmlApplicationContext("com"+File.separator+"li"+File.separator+"spring"+File.separator+"chineseidol"+File.separator+"chinese-idol.xml");
		Performer p=(Performer) ctx.getBean("li");
		try {
			p.perform();
		} catch (PerformanceException e) {
			e.printStackTrace();
		}
	}
```

其运行结果为：

```language
观众入座
观众关闭手机
JUGGLER 10 BALLS
鼓掌！
```

在前面的XML配置文件中，每一个通知（即Advice）定义的时候都会引用到一个切入点的表达式，这样显得比较冗余，我们还可以把前面的配置文件进行适当的简化，即把切入点表达式单独的拿出来：

```java
<aop:aspect ref="audience">
    <aop:pointcut expression="execution(* com.li.spring.chineseidol.Performer.perform(..))" id="performance"/>

    <aop:before pointcut-ref="performance" method="takeSeats"/>
    <aop:before pointcut-ref="performance" method="turnOffCellPhone"/>
    <aop:after-returning pointcut-ref="performance" method="applaud"/>
    <aop:after-throwing pointcut-ref="performance" method="demandRefund"/>

</aop:aspect>
```

&lt;aop-pointcut&gt; 单独定义了一个切入点，我们给它一个id，那么其他的通知（即Advice）就可以引用该切入点了。

#### 声明环绕通知

使用环绕通知可以完成前置和后置所实现的相同的功能，**只需在一个方法中实现。**

在Audience类中添加如下方法：

```language
/*环绕通知*/
public void watchPerformance(ProceedingJoinPoint joinpoint) {
    try {
        System.out.println("观众入座");
        System.out.println("观众关闭手机");

        long start=System.currentTimeMillis();
        joinpoint.proceed();
        long end=System.currentTimeMillis();

        System.out.println("观众鼓掌！");
        System.out.println("表演持续的时间是："+(end-start)+" 毫秒");
    } catch (Throwable e) {
        System.out.println("表演太糟糕了，我们要求退票！");
    }
}
```

该方法的参数跟连接点有关，其类型是 org.aspectj.lang.ProceedingJoinPoint。joinpoint.proceed 这一行代码就表示我们的业务逻辑方法执行，proceed()此方法会抛出异常，我们需要用try-catch包围，我们可以将抛出异常的后置通知放在处理异常的代码中。

配置文件中配置环绕通知，&lt;aop:around&gt; 表示配置一个环绕通知，watchPerformance是实现环绕通知的一个方法：

```xml
<aop:config>
    <aop:aspect ref="audience">
        <aop:pointcut expression="execution(* com.li.spring.chineseidol.Performer.perform(..))" id="performance"/>

        <aop:around pointcut-ref="performance" method="watchPerformance"/>

    </aop:aspect>
</aop:config>
```

运行：

```
观众入座
观众关闭手机
JUGGLER 10 BALLS
观众鼓掌！
表演持续的时间是：0 毫秒
```

#### 为通知传递一个参数

有时候不仅对方法进行简单的包装，还需要校验传递给方法的参数值，此时需要为通知传递参数。

```xml
<aop:aspect ref="beanName">
    <aop:pointcut expression="execution(* com.li.spring.chineseidol.TargetName.methodName(String)) and args(something)" id="pcID"/>

    <aop:before pointcut-ref="pcID" method="interceptMethod" arg-names="something"/>

</aop:aspect>
```

示例中切入点定义和 &lt;aop-before&gt; 的arg-names属性为关键。切入点标识了TargetName的methodName方法，指定String类型参数，然后在args参数中标识将something作为参数。

 &lt;aop-before&gt; 元素引用了something参数，标识该参数必须传递给 beanName 所属类型的interceptMethod方法。

#### 通过切面引入新的功能

利用 “引入Instruction” 这个AOP概念，切面可以为SpringBean添加新方法。

![切面引入.PNG](D:\桌面\TempPhoto\切面引入.PNG)

利用Spring AOP，可以为Bean引入新的方法。**代理拦截调用并委托给实现该方法的其他对象。**

示例演示让表演者Performer接口增加一个接受表彰的功能：receiveAward()

通过接口声明该功能方法：

```java
package com.li.spring.chineseidol;

public interface Contestant {
	void receiveAward();
}

```

借助AOP引入，可以不需要为设计妥协或侵入性地改变现有的实现，只需要使用 &lt;aop-declare-parents&gt; 元素。

```java
<aop:config>
    <aop:aspect ref="audience">
        <aop:pointcut expression="execution(* com.li.spring.chineseidol.Performer.perform(..))" id="performance"/>

        <aop:before pointcut-ref="performance" method="takeSeats"/>
        <aop:before pointcut-ref="performance" method="turnOffCellPhone"/>
        <aop:after-returning pointcut-ref="performance" method="applaud"/>
        <aop:after-throwing pointcut-ref="performance" method="demandRefund"/>

        <aop:declare-parents types-matching="com.li.spring.chineseidol.Performer+" implement-interface="com.li.spring.chineseidol.Contestant"
        default-impl="com.li.spring.chineseidol.GeneralContestant"/>

    </aop:aspect>
</aop:config>
```

&lt;aop-declare-parents&gt; 元素，types-matching属性表示匹配现有的接口，**注意后面的加号不可省略**，implement-interface表示引入的新的接口，新的接口含有新添加的功能，新的功能当然还未实现，所以我们需要委托给一个实现类，使用default-impl标注，下面给出的是实现类：

```java
package com.li.spring.chineseidol;

/*接受表彰的实现类*/

public class GeneralContestant implements Contestant{

	@Override
	public void receiveAward() {
		System.out.println("接受表彰！");
	}

}

```

<font color="red">**实际上，&lt;aop-declare-parents&gt; 声明了此切面所通知的Bean在它的对象层次结构中拥有的父类型。示例中类型匹配Performer接口（由types-matching属性指定）的那些Bean会实现Contestant接口（由implement-interface属性指定）。**</font>

所以一旦使用切面声明切面所通知的Bean拥有的父类型接口，并为其指定默认实现，那就可以将所通知的Bean上转型为父类型接口，从而调用添加进去的默认实现的方法

有两种方式标识所引入的接口：

- 使用default-impl属性通过完全限定类名显示指定Contestant的实现。

    ```xml
    <aop:declare-parents types-matching="com.li.spring.chineseidol.Performer+"
                implement-interface="com.li.spring.chineseidol.Contestant"
                default-impl="com.li.spring.chineseidol.GeneralContestant"/>
    ```

- 使用delegate-ref属性，引用一个Spring Bean作为引入的委托。

    ```xml
    <bean id="ContestantDelegate" class="com.li.spring.chineseidol.GeneralContestant"></bean>

    <aop:declare-parents types-matching="com.li.spring.chineseidol.Performer+" implement-interface="com.li.spring.chineseidol.Contestant"
            delegate-ref="ContestantDelegate"/>
    ```

在Audience类中修改测试代码测试代码：

```java
public static void main(String[] args) {
    ApplicationContext ctx=new ClassPathXmlApplicationContext("com"+File.separator+"li"+File.separator+"spring"+File.separator+"chineseidol"+File.separator+"chinese-idol.xml");
    Performer p=(Performer) ctx.getBean("li");
    try {
        p.perform();
        
        /*上转型为引入的方法所属的接口*/
        Contestant contestant=(Contestant) p;
        contestant.receiveAward();
    } catch (PerformanceException e) {
        e.printStackTrace();
    }
}

```

运行结果：

```
观众入座
观众关闭手机
JUGGLER 10 BALLS
鼓掌！
接受表彰！
```